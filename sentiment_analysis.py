# -*- coding: utf-8 -*-
"""sentiment-analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1L-Lot6zaCdrjTMBTBW96UhC0WVTUGlEU

## 0. Download the Dataset
"""

!git clone https://github.com/gonzoherme/Sentiment-Analysis-Data.git

run_with_train = False # should be False by default
run_with_eval = True

"""### 1. Import Required Packages"""

import pandas as pd
import numpy as np
import string

import torch
import torch.nn
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader

from sklearn.model_selection import train_test_split # to split dataset into train and test
from sklearn.feature_extraction.text import CountVectorizer, TfidfTransformer  # BOW, TF-IDF
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score


device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

"""### 2. Load the Dataset"""

df = pd.read_csv("./Sentiment-Analysis-Data/IMDB Dataset.csv", nrows = 10000)

# Map sentiments to {0,1}
sentiments = df['sentiment']
sentiments = sentiments.map({'positive': 1.0, 'negative': 0.0})

# Convert to csv
df.to_csv("./Sentiment-Analysis-Data/Full Dataset.csv", header = None, index = None)
df

"""### 3. Data Pre-Processing"""

# 3.1 Remove punctuation and conver to lowercase: reduces dimensionality without losing information
reviews = df['review']

def preprocess(sentence):
    sentence = sentence.lower() #lowercase
    translator = str.maketrans('', '', string.punctuation) #remove punctuation
    sentence = sentence.translate(translator)
    return sentence

processed_reviews = list(map(preprocess, reviews))

# 3.2 Convert to Bag of Words (BOW) representation
#vectorizer = CountVectorizer()
vectorizer = CountVectorizer(max_features=10000)
vectorizer.fit(processed_reviews) # fit: creates bow representation based on data
bow_representations = vectorizer.transform(processed_reviews) # transform: actually transforms data into bow representation
bow_array = bow_representations.toarray()

"""### 4. Defining the Dataset"""

class SentimentDataset(Dataset):
    def __init__(self, bow_reviews, sentiments):
        self.bow_reviews = bow_reviews
        self.sentiments = sentiments

    def __len__(self):
        return len(self.sentiments)

    def __getitem__(self, idx):
        return self.bow_reviews[idx], self.sentiments[idx]

# 4.1 Splitting into Train/Test
X_train, X_test, y_train, y_test = train_test_split(bow_array, sentiments, test_size=0.2, random_state=42)

# 4.1.1 Logistic Regression Dataset: BOW PyTorch datasets and dataloaders
train_dataset = SentimentDataset(X_train, y_train.values)
test_dataset = SentimentDataset(X_test, y_test.values)

train_loader = DataLoader(train_dataset, batch_size=64, shuffle=True)
test_loader = DataLoader(test_dataset, batch_size=64, shuffle=False)

# 4.1.2 k-NN Dataset: BOW + TF-IDF
# Apply TF-IDF to X_train (which is already in BOW format)
tfidf_transformer = TfidfTransformer()
tfidf_transformer.fit(X_train) # computes IDF
X_train_tfidf = tfidf_transformer.transform(X_train) # applies TF-IDF transformation

X_train_tfidf = X_train_tfidf.toarray()

# Apply TF-IDF to X_test
tfidf_transformer.fit(X_test)
X_test_tfidf = tfidf_transformer.transform(X_test)

X_test_tfidf = X_test_tfidf.toarray()

"""### 5. Models / Methods
**Logistic Regression**

* Used for supervised binary classification tasks. It maps input review texts to the probability (value between 0 and 1) they will be in a class ('positive' or 'negative').

* Our model consists of a single layer linear neural network, with a sigmoid activation function.

* We will embed the input text with BOW as input to the model.

**k-NN**

* Hard supervised classification algorithm.

* Does not require training, but we can calculate before-hand the distances between our data points to increase prediction efficiency.

* k-NN is not commonly used with BOW representations directly because it relies on the notion of distance between data points, and BOW representation does not inherently capture the semantic similarity between texts. Because of this, we have decided to use TF-IDF (Term Frequency-Inverse Document Frequency) to convert the BOW representation into a more meaningful numerical representation. We will then use KNN on these numerical representations.
"""

# 5.1 Defining Logistic Regression Model (single layer linear nn)
class LogisticRegression(torch.nn.Module):
    def __init__(self, input_dim, output_dim):
        super(LogisticRegression, self).__init__()
        self.linear = torch.nn.Linear(input_dim, output_dim)

    def forward(self, x):
        out = torch.sigmoid(self.linear(x))
        return out

# 5.2 k-NN Model (imported from sklearn)

# 5.3 Initializing the models
loss_fn = torch.nn.BCELoss()
loss_fn = loss_fn.to(device) # move loss function to device being used (CPU or GPU)

learning_rate = 0.01

# 5.3.1 Logistic Regression Model
input_dim = X_train.shape[1]
output_dim = 1 #logistic regression
log_model = LogisticRegression(input_dim, output_dim)

# 5.3.2 k-NN Model
num_neighbors = 7 #hyperparameter
knn_model = KNeighborsClassifier(n_neighbors = num_neighbors)

"""### 6. Training"""

# 6.1 Logistic Regression Model Training
def train_log():
  global log_model, train_loader, learning_rate

  optimizer = optim.SGD(log_model.parameters(), lr=learning_rate) # optimizer
  log_model.to(device) # move model to device being used (CPU or GPU)

  num_epochs = 30
  for epoch in range(num_epochs):
    log_model.train()

    num_correct_pred = 0
    total_pred = 0
    for xs, ys in train_loader:
      xs = xs.float()
      ys = ys.unsqueeze(1).float()

      # Forward pass
      preds = log_model(xs)
      loss = loss_fn(preds, ys)

      # Backward pass and optimization
      optimizer.zero_grad()
      loss.backward()
      optimizer.step()

      # Calculate accuracy
      predicted = (preds >= 0.5).float()
      total_pred += ys.size(0)
      num_correct_pred += (predicted == ys).sum().item()

    train_accuracy = num_correct_pred / total_pred
    if (epoch+1)%5 == 0: print(f'Epoch [{epoch+1}/{num_epochs}], Loss: {loss.item():.4f}, Training Accuracy: {train_accuracy:.4f}')

train_log()

# 6.2 k-NN "Training"
def fit_knn():
  global knn_model

  knn_model.fit(X_train_tfidf, y_train.values) #calculates distances between points

fit_knn()

"""### 7. Evaluation"""

# 7.1 Logistic Regression Model Eval
def eval_log():
  global log_model
  global test_loader

  log_model.eval()
  with torch.no_grad():
    num_correct_pred = 0
    total_pred = 0
    for xs, ys in test_loader:
        xs = xs.float()
        ys = ys.unsqueeze(1).float()

        # Forward pass
        preds = log_model(xs)

        # Calculate accuracy
        predicted = (preds >= 0.5).float()
        total_pred += ys.size(0)
        num_correct_pred += (predicted == ys).sum().item()

    accuracy = num_correct_pred / total_pred

    print(f'Accuracy: {accuracy:.2f}')
    return accuracy

if run_with_eval: eval_log()

# 7.2 k-NN Model Eval
def eval_knn():
  global knn_model
  global X_test_tfidf

  y_pred = knn_model.predict(X_test_tfidf)

  loss = loss_fn(torch.tensor(y_pred), torch.tensor(y_test.values))
  accuracy = accuracy_score(y_test, y_pred)

  print(f'Accuracy: {accuracy:.2f}')
  return accuracy



if run_with_eval: eval_knn()

"""### **Comparing Performance: Logistic Regression, k-NN**

* Accuracy:
  - Logistic Regression: 0.85
  - k-NN: 0.71

* From the results, it is clear that Logistic Regression does a significantly better job than k-NN at sentiment analysis. This is an expected result. Some ideas to back this result are the following:
  - **High-dimensionality**: in sentiment analysis, the feature space can be high-dimensional due to the large number of unique words in the corpus. k-NN's performance tends to degrade in high-dimensional spaces due to the curse of dimensionality. On the contrary, logistic regression is not affected by the curse of dimensionality and can handle high-dimensional feature spaces efficiently.
  - **Robustness to noise in data**: Logistic regression tends to be more robust to noisy data compared to k-NN. Since k-NN relies on local patterns in the feature space, noisy or irrelevant features can significantly affect its performance. Logistic regression, on the other hand, can downweight noisy features through regularization, making it more robust

### 8. Predict sentiment of a review
"""

# 8.1 Logistic Regression
def log_predict_sentiment(review):
  global log_model
  global vectorizer

  processed_rev = [preprocess(rev)]
  bow_representation = vectorizer.transform(processed_rev)
  bow_array = bow_representation.toarray()

  bow_tensor = torch.tensor(bow_array, dtype=torch.float32)

  # Predict
  with torch.no_grad():
    log_model.eval()
    output = log_model(bow_tensor)
    predicted = (output >= 0.5).float().item()
    return "Positive sentiment" if predicted == 1 else "Negative sentiment"

# 8.2 k-NN
def kNN_predict_sentiment(review):
  global vectorizer
  global tfidf_transformer

  processed_rev = [preprocess(rev)]
  bow_representation = vectorizer.transform(processed_rev)
  bow_array = bow_representation.toarray()

  tfidf = tfidf_transformer.transform(bow_array) # applies TF-IDF transformation
  tfidf_array = tfidf.toarray()

  output = int(knn_model.predict(tfidf_array)[0])
  return "Positive sentiment" if output == 1 else "Negative sentiment"

rev = "I thought the plot was ok, but I didn't really like the acting"
log_predict_sentiment(rev)
kNN_predict_sentiment(rev)

"""


---"""

# 8.2 k-NN
def kNN_predict_sentiment(review):
  global vectorizer
  global tfidf_transformer

  processed_rev = [preprocess(rev)]
  bow_representation = vectorizer.transform(processed_rev)
  bow_array = bow_representation.toarray()

  tfidf = tfidf_transformer.transform(bow_array) # applies TF-IDF transformation
  tfidf_array = tfidf.toarray()

  output = int(knn_model.predict(tfidf_array)[0])
  return "Positive sentiment" if output == 1 else "Negative sentiment"
kNN_predict_sentiment(rev)

"""# **Experimental**

* Our experiment will consist in analyzing how the dimensionality of the word embeddings, specifically BOW, affect the accuracy of sentiment analyisis models. We want to explore how a reduction in dimensionality, which reduces computation cost, trades off with model accuracy.

* To do this, we will train and test both of our models (Logistic Regression and k-NN) with the following limits on the dimension of the word embeddings: *(50, 100, 500, 1000, 3000, 5000, 8000, 10000, 15000, 20000, 30000, 40000, 50000, 60000, no_limit)*. We will compare how their accuracies fluctuate.
"""

def setup_datasets(feature_dim_limit):
  global vectorizer, bow_representations, bow_array
  global X_train, X_test, y_train, y_test
  global train_dataset, test_dataset, train_loader, test_loader
  global tfidf_transformer, X_train_tfidf, X_test_tfidf


  vectorizer = CountVectorizer(max_features=feature_dim_limit)
  vectorizer.fit(processed_reviews) # fit: creates bow representation based on data
  bow_representations = vectorizer.transform(processed_reviews) # transform: actually transforms data into bow representation
  bow_array = bow_representations.toarray()

  # Splitting into Train/Test
  X_train, X_test, y_train, y_test = train_test_split(bow_array, sentiments, test_size=0.2, random_state=42)

  # Logistic Regression Dataset: BOW PyTorch datasets and dataloaders
  train_dataset = SentimentDataset(X_train, y_train.values)
  test_dataset = SentimentDataset(X_test, y_test.values)

  train_loader = DataLoader(train_dataset, batch_size=64, shuffle=True)
  test_loader = DataLoader(test_dataset, batch_size=64, shuffle=False)

  # k-NN Dataset: BOW + TF-IDF
  tfidf_transformer = TfidfTransformer()
  tfidf_transformer.fit(X_train)
  X_train_tfidf = tfidf_transformer.transform(X_train)
  X_train_tfidf = X_train_tfidf.toarray()

  # Apply TF-IDF to X_test
  tfidf_transformer.fit(X_test)
  X_test_tfidf = tfidf_transformer.transform(X_test)
  X_test_tfidf = X_test_tfidf.toarray()

def perform_experiment():
  global input_dim
  global log_model, knn_model

  log_accuracy, knn_accuracy = [], []
  feature_limits = [50, 100, 500, 1000, 3000, 5000, 8000, 10000, 15000, 20000, 30000, 40000, 50000, 60000]

  for feat_dim_lim in feature_limits:
    #train_loader, X_train_tfidf, y_train, test_loader, X_test_tfidf, y_test = setup_datasets(feature_limits)
    setup_datasets(feat_dim_lim)
    assert(feat_dim_lim == X_train_tfidf.shape[1])

    # Reset log_model
    input_dim=feat_dim_lim; output_dim=1
    log_model = LogisticRegression(input_dim, output_dim)

    # Train log_model
    print('\n')
    print(f'Feature Limit: {feat_dim_lim}')
    print(f'Train Logistic Regression')
    train_log()

    # Eval log_model
    print('\n')
    print(f'Eval Loggistic Regression')
    acc = eval_log()
    print('---acc: ', acc)
    log_accuracy.append(acc)
    print('log_accuracy: ', log_accuracy)

    print('\n')
    # Reset knn_model
    knn_model = KNeighborsClassifier(n_neighbors=num_neighbors)

    # Fit knn_model
    print(f'Fit knn')
    fit_knn()

    # Eval knn_model
    print(f'Eval knn')
    acc = eval_knn()
    knn_accuracy.append(acc)

    print('knn_accuracy: ', knn_accuracy)

if run_with_train: perform_experiment()

"""# **Results**

### Output Graphs
"""

import matplotlib.pyplot as plt

feature_limits = [50, 100, 500, 1000, 3000, 5000, 8000, 10000, 15000, 20000, 30000, 40000]

log_accuracy = [0.63, 0.7215, 0.8185, 0.8365, 0.845, 0.8475, 0.8515, 0.8475, 0.8485, 0.85, 0.852, 0.851]
knn_accuracy = [0.5995, 0.6325, 0.674, 0.67, 0.686, 0.6965, 0.7045, 0.7125, 0.7195, 0.715, 0.712, 0.7095]

log_accuracy = np.array(log_accuracy)
knn_accuracy = np.array(knn_accuracy)

#coefficients_log = np.polyfit(feature_limits, log_accuracy, deg=2)
#poly_function_log = np.poly1d(coefficients_log)

#coefficients_knn = np.polyfit(feature_limits, knn_accuracy, deg=2)
#poly_function_knn = np.poly1d(coefficients_knn)

# generating points for the curve
#x_curve = np.linspace(min(feature_limits), max(feature_limits), 100)
#y_curve_log = poly_function_log(x_curve)
#y_curve_knn = poly_function_knn(x_curve)

plt.scatter(feature_limits, log_accuracy, label='Logistic Regression')
plt.scatter(feature_limits, knn_accuracy, label='k-NN')

#plt.plot(x_curve, y_curve_log, label='log_accuracy', color='green')
#plt.plot(x_curve, y_curve_knn, label='log_accuracy', color='purple')

plt.xlabel('Feature Limits')
plt.ylabel('Accuracy')

plt.legend()
plt.grid(True)
plt.show()

"""**Saved Output Graph:**

![image.png](data:image/png;base64,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REAEAkVACiyx5uJjZA2eEkOm2CIgAiLgDQEpsAS4prKNYQLFKKoIiIAIiIADAjLicACpIIrZxtC+lYbZxhB/p1kongiIgAiIgHsEpMAcsUx9G0NHxSiSCIiACIiAYwJSYI5QFbqNoaNcFEkEREAERMA9AlJgjljG36gwfqijAhRJBERABEQgQQJSYI6Axd+oMH6oowIUSQREQAREIEECUmCOgJltDCO3bMInDU+NclQlRRIBERCBgBOQAnPUgHx6zHaFRLXrMONOdBtDR+UpkgiIgAiIQGEEpMAKI3QgXNsYHiChvyIgAiKQFgT0IXMCzaBtDBOApagiIAIi4DEBKbDEAGsbw8R4KbYIiIAIeEZAU4ieoVXGIiACIiACXhKQAvOSrvIWAREQARHwjIAUmGdolbEIiIAIiICXBKTAvKSrvEVABERABDwjIAXmGVplLAIiIAIi4CUBKTAv6SpvERABERABzwhIgXmGVhmLgAiIgAh4SUAKzEu6ylsEREAERMAzAlJgnqFVxiIgAiIgAl4SkALzkq7yFgEREAER8IyAFJhnaJWxCIiACIiAlwSkwLykq7xFQAREQAQ8I6DNfAtBuz83b+E3WzZu382xyxxryWa+hSRQsAiIgAiIgC8EpMDiYZ6xZN2I179ct3W3icThyxxfyaEq8dIoTAREQAREwBcCmkKMiRnt1efZxZb2It76rbvxwT9mGgWIgAiIgAj4RUAKLDppZg4Ze+UdGmhu8Sf00BDdiYAIiIAI+E1ACiw68UXf/WQfe1mRUFz4sypm+cghAiIgAiJQJASkwKJj37xjT/SAAl9sOuKEKkgEREAERMAHAlJg0SFXOqJ09IACXywS44QqSAREQAREwAcCUmDRITetdRQ2h5Em8/jgjz199GTyFQEREAER8IuAFFh00nzvhcU8YXYdZtz462uw6NTkKwIiIAI+EpACiwmb770evfLUqkcenC3EjY++A4uJTAEiIAIi4CMBfcgcDza6ql2DqtqJIx4jhYmACIhAERGQAisEPLOFLetWLCSSgkVABERABHwnoClE35GrQBEQAREQATcISIG5QVF5iIAIiIAI+E5ACsx35CpQBERABETADQJSYG5QVB4iIAIiIAK+E5AC8x25ChQBERABEXCDgBSYGxSVhwiIgAiIgO8EpMB8R64CRUAEREAE3CAgBeYGReUh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c3NxW9OJllitW7dGLRFqfL766itUWpj2Ioi5xJUrVxJkJZRDBERABEQgmwl4qMDAig39hAkTJk2atHTp0j59+uzcudNYJHbv3t0y7sAfK8R+/fqhujBTvOeeezDoME1yyy23sGbGChkLaRdffDGjtK5du2Zza6nuIiACIiACFgEPpxApo0uXLps2bRo6dCizgk2aNJkxY0aVKlXwX716NUaJRgiWrN56662bb765UaNGGH2gybBCNEE//PADGuvHH3/EOrFNmzbz58/HYYL0KwIiIAIikOUEvFVgwL2x4AqjPGfOHLsP84ooJ7uPcU+ZMiXSUz4iIAIiIAIiAAFvpxCFWAREQAREQAQ8IiAF5hFYZSsCIiACIuAtASkwb/kqdxEQAREQAY8ISIF5BFbZioAIiIAIeEtACsxbvspdBERABETAIwJSYB6BVbYiIAIiIALeEpAC85avchcBERABEfCIgBSYR2CVrQiIgAiIgLcEpMC85avcRUAEREAEPCIgBeYRWGUrAiIgAiLgLQEpMG/5KncREAEREAGPCEiBRYDN3Z/v9eWroW/eDxl3RBR5iIAIiIAIFDkBKbBDm+DL10KPtMj3erVvaNIFoTEnh/DRJQIiIAIikH4EpMBsbYKueqF7aPu6g17b1uX7SIcdJCKXCIiACKQLASmwAy3BbOEMziHLO3Bv/hbczhikucRDsehOBERABIqegBTYgTb4bm5o29oDN/a/eaFta0KE6hIBERABEUgnAlJgB1pjx4YDrmh/44dGSyE/ERABERABTwlIgf2Gd//hleOAjh8aJ6GCREAEREAEPCIgBfYb2IX766/Nq5AbtgQWCuGzNq8ioR41gLIVAREQARFIjoAU2G/cNu7cN2Jfd27sOsy4R+y7itDk+CqVCIiACIiARwSkwH4DW7lcmbdym/XZ139j6CiL9fpQRXzwJ9TylEMEREAERCAdCJRIByHSQYZmdSpUO7LMzK3N3tvb9N5Q3sB9vdftL78wt35eqBj+hKaDkJJBBERABETAIqAR2G8oihfLGdapATdoLH6n5Tafn9vAuPEn1EImhwiIgAiIQDoQ0AjsYCt0PLnao1eeOurNL0Khnca36pFl0F74H4wklwiIQLIE9u/fv29fmi4nI1iJEiV2796NkMnWz490GSlnyZIlixcvngQ+KbBDoKGrzvp9xbdmTL//0kaVjzycmUONvQ4BpBsRSIpAXl7e+vXrf/7556RS+5EICatWrfr999/n5KT1dEumyvm73/0O/onClwIL/98wGuu8htV4KQgP070IiEBSBIz2qly5ctmyZRN9SCVVYMKJcnNzd+zYccQRRxQrltYLK5knJyp5165dGzdupM2qVUtsuksKLOGOrgQiIAIJEWBSjrEX2qtixYoJJfQzMoph7969ZcqUSX8FlnlyHnbYYbQ1OoxOktBcYlq/a/jZfVWWCIiARwR+/fVXcmbs5VH+yjYDCJjukegSqRRYBjS9qiACaU2AOSLkS8+Zw7QGl03CJdc9pMCyqY+oriIgAiKQQQSkwDKoMVUVERABHwnUrl17zJgxzgt86qmnsLVzHj8QMROF4G6lpMDc5ancREAE0prANddc07lzZ1dE/N///te7d+84WYU93Lt06fLVV1/FiR8WhMJjYo0LuxLM80i+evXqsDhFflsoBE8llALzFK8yFwERSJ7A/ty8eSt/fPWTNfziTj4jb1IeffTRCVmmYGuHlV1CspQvX37dunVr1qz597//vXz58j/+8Y8JJY8TOVFziVhZJQohVj7J+UuBJcdNqURABLwlMGPJujb3vdN1wvx+Uz7hFzc+3hX57rvvnnPOOegYxjqDBg0ylpMUt3379j/96U+HH344/g8++OBZZ53Vv39/I4Y1wMJKZfjw4ccee2zp0qWrV69+0003EYGY33333c0332xGUfiETSG+/vrrp59+Oob7lSpVuvjii02eYb+k5fNeim7VqlXPnj0XLly4bds2E+fVV1899dRTSX7ccceNGDHCEnjZsmVt2rTBv0GDBm+//TY5/Oc//yHJt99+i3vq1Kl/+MMfCH3uuefwfPzxx0888URu69ev/8gjj5icMdO/8cYbKRT/WrVqjRo1Cv+odcTfgoCbAeJFF13Et3ToXcaL5tMu/IHTpEmTZ555hshHHnnkFVdcAVX8U7/0HVjqDJWDCIiAywTQVX2eXWwfc63fuhsfNnvzYms3hjgXXHBB165decgyy9erVy+e3Tx2qdWAAQM+/PDD1157rUqVKkOHDl28eDHP4rDaMjxCt02ZMuWkk07ik+1PP/2UCC+//HLjxo2ZYyS3sPjcvvnmmyit22+//emnn0ZhTJs2LTKO3Qdl8Morr/CNFBff1b3//vvdu3cfO3bsGWec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)

### Experiment Output Log
"""

'''
Feature Limit: 50
Train Logistic Regression
Epoch [5/30], Loss: 0.6146, Training Accuracy: 0.6436
Epoch [10/30], Loss: 0.6339, Training Accuracy: 0.6525
Epoch [15/30], Loss: 0.6027, Training Accuracy: 0.6520
Epoch [20/30], Loss: 0.5664, Training Accuracy: 0.6549
Epoch [25/30], Loss: 0.7000, Training Accuracy: 0.6480
Epoch [30/30], Loss: 0.5521, Training Accuracy: 0.6542


Eval Loggistic Regression
---acc:  0.63
log_accuracy:  [0.63]


Fit knn
Eval knn
knn_accuracy:  [0.5995]


Feature Limit: 100
Train Logistic Regression
Epoch [5/30], Loss: 0.6093, Training Accuracy: 0.7153
Epoch [10/30], Loss: 0.4846, Training Accuracy: 0.7322
Epoch [15/30], Loss: 0.6263, Training Accuracy: 0.7364
Epoch [20/30], Loss: 0.5017, Training Accuracy: 0.7382
Epoch [25/30], Loss: 0.4175, Training Accuracy: 0.7384
Epoch [30/30], Loss: 0.5901, Training Accuracy: 0.7419


Eval Loggistic Regression
---acc:  0.7215
log_accuracy:  [0.63, 0.7215]


Fit knn
Eval knn
knn_accuracy:  [0.5995, 0.6325]


Feature Limit: 500
Train Logistic Regression
Epoch [5/30], Loss: 0.4647, Training Accuracy: 0.7843
Epoch [10/30], Loss: 0.4077, Training Accuracy: 0.8096
Epoch [15/30], Loss: 0.4098, Training Accuracy: 0.8194
Epoch [20/30], Loss: 0.4276, Training Accuracy: 0.8255
Epoch [25/30], Loss: 0.3700, Training Accuracy: 0.8314
Epoch [30/30], Loss: 0.4259, Training Accuracy: 0.8343


Eval Loggistic Regression
---acc:  0.8185
log_accuracy:  [0.63, 0.7215, 0.8185]


Fit knn
Eval knn
knn_accuracy:  [0.5995, 0.6325, 0.674]


Feature Limit: 1000
Train Logistic Regression
Epoch [5/30], Loss: 0.4781, Training Accuracy: 0.7991
Epoch [10/30], Loss: 0.4350, Training Accuracy: 0.8253
Epoch [15/30], Loss: 0.3662, Training Accuracy: 0.8349
Epoch [20/30], Loss: 0.3486, Training Accuracy: 0.8474
Epoch [25/30], Loss: 0.3590, Training Accuracy: 0.8491
Epoch [30/30], Loss: 0.3999, Training Accuracy: 0.8584


Eval Loggistic Regression
---acc:  0.8365
log_accuracy:  [0.63, 0.7215, 0.8185, 0.8365]


Fit knn
Eval knn
knn_accuracy:  [0.5995, 0.6325, 0.674, 0.67]


Feature Limit: 3000
Train Logistic Regression
Epoch [5/30], Loss: 0.4822, Training Accuracy: 0.8037
Epoch [10/30], Loss: 0.4752, Training Accuracy: 0.8379
Epoch [15/30], Loss: 0.3249, Training Accuracy: 0.8520
Epoch [20/30], Loss: 0.4475, Training Accuracy: 0.8614
Epoch [25/30], Loss: 0.3566, Training Accuracy: 0.8662
Epoch [30/30], Loss: 0.4598, Training Accuracy: 0.8772


Eval Loggistic Regression
---acc:  0.845
log_accuracy:  [0.63, 0.7215, 0.8185, 0.8365, 0.845]


Fit knn
Eval knn
knn_accuracy:  [0.5995, 0.6325, 0.674, 0.67, 0.686]


Feature Limit: 5000
Train Logistic Regression
Epoch [5/30], Loss: 0.4196, Training Accuracy: 0.8106
Epoch [10/30], Loss: 0.4396, Training Accuracy: 0.8384
Epoch [15/30], Loss: 0.4159, Training Accuracy: 0.8520
Epoch [20/30], Loss: 0.3913, Training Accuracy: 0.8685
Epoch [25/30], Loss: 0.4164, Training Accuracy: 0.8775
Epoch [30/30], Loss: 0.3898, Training Accuracy: 0.8805


Eval Loggistic Regression
---acc:  0.8475
log_accuracy:  [0.63, 0.7215, 0.8185, 0.8365, 0.845, 0.8475]


Fit knn
Eval knn
knn_accuracy:  [0.5995, 0.6325, 0.674, 0.67, 0.686, 0.6965]


Feature Limit: 8000
Train Logistic Regression
Epoch [5/30], Loss: 0.5023, Training Accuracy: 0.8081
Epoch [10/30], Loss: 0.4017, Training Accuracy: 0.8403
Epoch [15/30], Loss: 0.4183, Training Accuracy: 0.8551
Epoch [20/30], Loss: 0.3023, Training Accuracy: 0.8704
Epoch [25/30], Loss: 0.3281, Training Accuracy: 0.8795
Epoch [30/30], Loss: 0.3119, Training Accuracy: 0.8859


Eval Loggistic Regression
---acc:  0.8515
log_accuracy:  [0.63, 0.7215, 0.8185, 0.8365, 0.845, 0.8475, 0.8515]


Fit knn
Eval knn
knn_accuracy:  [0.5995, 0.6325, 0.674, 0.67, 0.686, 0.6965, 0.7045]


Feature Limit: 10000
Train Logistic Regression
Epoch [5/30], Loss: 0.4867, Training Accuracy: 0.8096
Epoch [10/30], Loss: 0.4461, Training Accuracy: 0.8383
Epoch [15/30], Loss: 0.3146, Training Accuracy: 0.8570
Epoch [20/30], Loss: 0.2988, Training Accuracy: 0.8711
Epoch [25/30], Loss: 0.3374, Training Accuracy: 0.8808
Epoch [30/30], Loss: 0.3349, Training Accuracy: 0.8880


Eval Loggistic Regression
---acc:  0.8475
log_accuracy:  [0.63, 0.7215, 0.8185, 0.8365, 0.845, 0.8475, 0.8515, 0.8475]


Fit knn
Eval knn
knn_accuracy:  [0.5995, 0.6325, 0.674, 0.67, 0.686, 0.6965, 0.7045, 0.7125]


Feature Limit: 15000
Train Logistic Regression
Epoch [5/30], Loss: 0.4563, Training Accuracy: 0.8090
Epoch [10/30], Loss: 0.3128, Training Accuracy: 0.8440
Epoch [15/30], Loss: 0.3821, Training Accuracy: 0.8608
Epoch [20/30], Loss: 0.3075, Training Accuracy: 0.8729
Epoch [25/30], Loss: 0.3467, Training Accuracy: 0.8812
Epoch [30/30], Loss: 0.2839, Training Accuracy: 0.8901


Eval Loggistic Regression
---acc:  0.8485
log_accuracy:  [0.63, 0.7215, 0.8185, 0.8365, 0.845, 0.8475, 0.8515, 0.8475, 0.8485]


Fit knn
Eval knn
knn_accuracy:  [0.5995, 0.6325, 0.674, 0.67, 0.686, 0.6965, 0.7045, 0.7125, 0.7195]


Feature Limit: 20000
Train Logistic Regression
Epoch [5/30], Loss: 0.4811, Training Accuracy: 0.8097
Epoch [10/30], Loss: 0.4729, Training Accuracy: 0.8431
Epoch [15/30], Loss: 0.4474, Training Accuracy: 0.8602
Epoch [20/30], Loss: 0.3674, Training Accuracy: 0.8734
Epoch [25/30], Loss: 0.4233, Training Accuracy: 0.8802
Epoch [30/30], Loss: 0.2801, Training Accuracy: 0.8924


Eval Loggistic Regression
---acc:  0.85
log_accuracy:  [0.63, 0.7215, 0.8185, 0.8365, 0.845, 0.8475, 0.8515, 0.8475, 0.8485, 0.85]


Fit knn
Eval knn
knn_accuracy:  [0.5995, 0.6325, 0.674, 0.67, 0.686, 0.6965, 0.7045, 0.7125, 0.7195, 0.715]


Feature Limit: 30000
Train Logistic Regression
Epoch [5/30], Loss: 0.4542, Training Accuracy: 0.8100
Epoch [10/30], Loss: 0.4298, Training Accuracy: 0.8472
Epoch [15/30], Loss: 0.3604, Training Accuracy: 0.8621
Epoch [20/30], Loss: 0.3281, Training Accuracy: 0.8718
Epoch [25/30], Loss: 0.3217, Training Accuracy: 0.8850
Epoch [30/30], Loss: 0.2328, Training Accuracy: 0.8922


Eval Loggistic Regression
---acc:  0.852
log_accuracy:  [0.63, 0.7215, 0.8185, 0.8365, 0.845, 0.8475, 0.8515, 0.8475, 0.8485, 0.85, 0.852]


Fit knn
Eval knn
knn_accuracy:  [0.5995, 0.6325, 0.674, 0.67, 0.686, 0.6965, 0.7045, 0.7125, 0.7195, 0.715, 0.712]


Feature Limit: 40000
Train Logistic Regression
Epoch [5/30], Loss: 0.4453, Training Accuracy: 0.8116
Epoch [10/30], Loss: 0.3893, Training Accuracy: 0.8454
Epoch [15/30], Loss: 0.2755, Training Accuracy: 0.8644
Epoch [20/30], Loss: 0.3642, Training Accuracy: 0.8745
Epoch [25/30], Loss: 0.2550, Training Accuracy: 0.8856
Epoch [30/30], Loss: 0.2928, Training Accuracy: 0.8916


Eval Loggistic Regression
---acc:  0.851
log_accuracy:  [0.63, 0.7215, 0.8185, 0.8365, 0.845, 0.8475, 0.8515, 0.8475, 0.8485, 0.85, 0.852, 0.851]


Fit knn
Eval knn
knn_accuracy:  [0.5995, 0.6325, 0.674, 0.67, 0.686, 0.6965, 0.7045, 0.7125, 0.7195, 0.715, 0.712, 0.7095]
'''

"""#**Discussion**

* As depicted in the graphs, our expectations were met: the higher the dimensionality of the embedded data, the greater the accuracy of our models. A larger embedded space allows us to capture more information from the input, thereby enhancing the predictive capabilities of our models.

* We can also observe that the performance of logistic regression surpasses that of k-NN. We have already discussed this comparison extensively in the Methods section.

* However, the observation of most interest, which is directly related to our experimental inquiry, is that model accuracy tends to plateau after a certain number of features in our embedded space. This is most likely due to the fact that an excessive increase in features may introduce irrelevant information to the classification task. In other words,

* How does this experimental result affect us moving forward? Well, it gives us clues towards achieving an optimal dimensionality for our embedded space in terms of maximizing embedded information, as well as minimizing computation costs associated with high dimensionality. From the graphs, we can clearly see that this optimal dimensionality lies at the "inverse knee" of the graphs, located at the start of the accuracy plateau. This strategic dimensionality allows us to approach maximum model accuracy while minimizing the computational burden by utilizing the fewest features necessary.
"""